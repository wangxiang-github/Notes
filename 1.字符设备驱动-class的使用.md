## `kernel`基线版本为 `5.4.42`
## 文件位置：`linux-5.4.42/drivers/gpu/drm/amd/amdkfd/kfd_chardev.c`

```
static long kfd_ioctl(struct file *, unsigned int, unsigned long);
static int kfd_open(struct inode *, struct file *);
static int kfd_mmap(struct file *, struct vm_area_struct *);

static const char kfd_dev_name[] = "kfd";

static const struct file_operations kfd_fops = {
	.owner = THIS_MODULE,
	.unlocked_ioctl = kfd_ioctl,
	.compat_ioctl = kfd_ioctl,
	.open = kfd_open,
	.mmap = kfd_mmap,
};

static int kfd_char_dev_major = -1;
static struct class *kfd_class;
struct device *kfd_device;

int kfd_chardev_init(void)
{
	int err = 0;

	kfd_char_dev_major = register_chrdev(0, kfd_dev_name, &kfd_fops);
	err = kfd_char_dev_major;
	if (err < 0)
		goto err_register_chrdev;

	kfd_class = class_create(THIS_MODULE, kfd_dev_name);
	err = PTR_ERR(kfd_class);
	if (IS_ERR(kfd_class))
		goto err_class_create;

	kfd_device = device_create(kfd_class, NULL, MKDEV(kfd_char_dev_major, 0), NULL, kfd_dev_name);
	err = PTR_ERR(kfd_device);
	if (IS_ERR(kfd_device))
		goto err_device_create;

	return 0;

err_device_create:
	class_destroy(kfd_class);
err_class_create:
	unregister_chrdev(kfd_char_dev_major, kfd_dev_name);
err_register_chrdev:
	return err;
}

void kfd_chardev_exit(void)
{
	device_destroy(kfd_class, MKDEV(kfd_char_dev_major, 0));
	class_destroy(kfd_class);
	unregister_chrdev(kfd_char_dev_major, kfd_dev_name);
}

......
```
### 函数 kfd_chardev_init 执行成功后，会建立一系列文件：
- 在 `/dev`下建立 `kfd` 的设备节点
- 在 `/sys/devices/virtual` 下生成名为 `kdf` 的设备驱动
- 在 `/sys/class` 下建立名为 `kfd` 的 `class` 类，并在其下再建立符号链接`kfd`，指向 `/sys/devices/virtual/kfd` 设备

### 在此背景下，如果再新建立一个 `class` 类，并建立符号链接，也指向 `/sys/devices/virtual/kfd` 设备，该如何做？
```
#define CLASS_COMAPT_KFD "compat_kfd"

/* 定义一个兼容型class类: class_compat */
static struct class_compat *kfd_compat_class;

int kfd_chardev_init(void)
{
	int err = 0;

	kfd_char_dev_major = register_chrdev(0, kfd_dev_name, &kfd_fops);
	err = kfd_char_dev_major;
	if (err < 0)
		goto err_register_chrdev;

	kfd_class = class_create(THIS_MODULE, kfd_dev_name);
	err = PTR_ERR(kfd_class);
	if (IS_ERR(kfd_class))
		goto err_class_create;

	kfd_device = device_create(kfd_class, NULL, MKDEV(kfd_char_dev_major, 0), NULL, kfd_dev_name);
	err = PTR_ERR(kfd_device);
	if (IS_ERR(kfd_device))
		goto err_device_create;

	/* 注册 class_compat 兼容型class类 */
	kfd_compat_class = class_compat_register(CLASS_COMAPT_KFD);
	err = PTR_ERR(kfd_compat_class);
	if (IS_ERR(kfd_compat_class))
		goto err_device_create;

	/* 建立符号链接，符号名为 kfd, 指向 /sys/devices/virtual/kfd 设备 */
	err = class_compat_create_link(kfd_compat_class, kfd_device, NULL)
	if (err)
		goto err_compat_class_create;

	return 0;

err_compat_class_create:
	class_compat_unregister(kfd_compat_class);
err_device_create:
	class_destroy(kfd_class);
err_class_create:
	unregister_chrdev(kfd_char_dev_major, kfd_dev_name);
err_register_chrdev:
	return err;
}

/* 注册退出函数，先移除符号链接，再注销compat_class类 */
void kfd_chardev_exit(void)
{
	class_compat_remove_link(kfd_compat_class, kfd_device, NULL);
	class_compat_unregister(kfd_compat_class);
	device_destroy(kfd_class, MKDEV(kfd_char_dev_major, 0));
	class_destroy(kfd_class);
	unregister_chrdev(kfd_char_dev_major, kfd_dev_name);
}
```